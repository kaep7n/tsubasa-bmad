# Story 1.7: Offline Foundation (Service Worker & IndexedDB)

## Status
Draft

## Story
**As a** developer,
**I want** Service Worker and IndexedDB infrastructure in place,
**so that** offline functionality can be built incrementally

## Acceptance Criteria
1. ✅ Angular Service Worker configured via `@angular/service-worker`
2. ✅ `ngsw-config.json` created with cache strategies:
   - **App shell**: Cache all HTML, CSS, JS bundles
   - **Fonts**: Cache Google Fonts (if used) or local fonts
   - **Images**: Cache Material icons and team logos (max 50MB)
   - **Data**: No API caching (handled by IndexedDB sync)
3. ✅ Service Worker registered in `main.ts` (production builds only)
4. ✅ Dexie.js installed (IndexedDB wrapper for TypeScript)
5. ✅ `DatabaseService` created with Dexie schema:
   - Tables: `teams`, `players`, `games`, `training_sessions`, `goals`, `goal_assists`, `opponent_goals`, `game_attendance`, `training_attendance`, `sync_queue`
   - Indexes: Foreign keys (e.g., `players.team_id`, `goals.game_id`)
6. ✅ `SyncService` created with methods:
   - `queueOperation(table, operation, data)` - Adds to sync queue
   - `processSyncQueue()` - Syncs queued operations to Supabase
   - `pullChanges()` - Fetches updates from Supabase since last sync
   - `resolveConflict(local, remote)` - Last-write-wins by `updated_at`
7. ✅ Sync triggered on:
   - App startup (if online)
   - Network reconnection (via `navigator.onLine` listener)
   - Manual refresh (pull-to-refresh)
8. ✅ Sync status exposed via Signal: `syncState()` returns 'pending' | 'syncing' | 'synced' | 'error'
9. ✅ Unit test: Verify sync queue operations and conflict resolution
10. ✅ E2E test: Create record offline, go online, verify sync to Supabase

## Tasks / Subtasks

- [ ] **Task 1: Install Angular Service Worker** (AC: 1)
  - [ ] Install package: `ng add @angular/pwa`
  - [ ] Verify `@angular/service-worker` added to package.json
  - [ ] Verify manifest.json created in /src
  - [ ] Verify PWA icons added to /src/assets/icons
  - [ ] Confirm ngsw-config.json created in project root

- [ ] **Task 2: Configure Service Worker Cache Strategies** (AC: 2)
  - [ ] Edit `ngsw-config.json` with cache strategies:
    - **App Shell**: Cache index.html and static assets (assetGroups)
    - **Lazy Routes**: Cache lazy-loaded bundles
    - **Fonts**: Cache fonts from CDN or local fonts
    - **Images**: Cache Material icons and team logos (max 50MB)
    - **Data**: No API caching (remove dataGroups if present)
  - [ ] Set cache versioning strategy (installMode, updateMode)
  - [ ] Configure cache expiration policies

- [ ] **Task 3: Register Service Worker in main.ts** (AC: 3)
  - [ ] Import ServiceWorkerModule in app config
  - [ ] Register Service Worker for production only:
    ```typescript
    importProvidersFrom(
      ServiceWorkerModule.register('ngsw-worker.js', {
        enabled: environment.production,
        registrationStrategy: 'registerWhenStable:30000'
      })
    )
    ```
  - [ ] Verify Service Worker not registered in development
  - [ ] Build and test in production mode

- [ ] **Task 4: Install Dexie.js** (AC: 4)
  - [ ] Install Dexie: `npm install dexie`
  - [ ] Install types: `npm install --save-dev @types/dexie`
  - [ ] Verify installation in package.json

- [ ] **Task 5: Create DatabaseService with Dexie Schema** (AC: 5)
  - [ ] Create `/src/app/core/services/database.service.ts`
  - [ ] Define Dexie database class extending Dexie
  - [ ] Define schema with all tables:
    - teams, players, games, training_sessions
    - goals, goal_assists, opponent_goals
    - game_attendance, training_attendance
    - sync_queue
  - [ ] Define indexes for foreign keys:
    - players: &id, team_id, coach_id
    - games: &id, coach_id, date
    - goals: &id, game_id, scorer_id
    - sync_queue: &id, ++timestamp, synced
  - [ ] Initialize database on service instantiation
  - [ ] Export singleton database instance

- [ ] **Task 6: Create Sync Queue Data Model** (AC: 6)
  - [ ] Create `/src/app/core/models/sync-operation.model.ts`
  - [ ] Define SyncOperation interface:
    ```typescript
    interface SyncOperation {
      id: string;
      table: string;
      operation: 'insert' | 'update' | 'delete';
      data: any;
      timestamp: number;
      synced: boolean;
      retries: number;
      error?: string;
    }
    ```
  - [ ] Add to Dexie schema: sync_queue table

- [ ] **Task 7: Create SyncService - Queue Operations** (AC: 6)
  - [ ] Create `/src/app/core/services/sync.service.ts`
  - [ ] Implement `queueOperation(table, operation, data)`:
    - Add operation to sync_queue table in IndexedDB
    - Set synced = false, timestamp = Date.now()
    - Return Promise<void>
  - [ ] Implement optimistic updates:
    - Update local IndexedDB immediately
    - Queue operation for sync
    - Return success to UI

- [ ] **Task 8: Create SyncService - Process Queue** (AC: 6)
  - [ ] Implement `processSyncQueue()`:
    - Query sync_queue where synced = false, order by timestamp ASC
    - For each operation:
      - Execute operation against Supabase (insert/update/delete)
      - Mark synced = true on success
      - Increment retries on failure (max 3)
      - Store error message if all retries fail
    - Return sync summary (success count, failed count)
  - [ ] Use exponential backoff for retries

- [ ] **Task 9: Create SyncService - Pull Changes** (AC: 6)
  - [ ] Implement `pullChanges()`:
    - Query Supabase for records updated since last sync
    - Store last_sync_timestamp in localStorage
    - For each changed record:
      - Check if exists in IndexedDB
      - If exists, call resolveConflict(local, remote)
      - If not exists, insert into IndexedDB
    - Update last_sync_timestamp
    - Return count of records pulled

- [ ] **Task 10: Implement Conflict Resolution** (AC: 6)
  - [ ] Implement `resolveConflict(local, remote)`:
    - Compare updated_at timestamps
    - Use "last write wins" strategy (most recent updated_at)
    - Update IndexedDB with winning record
    - If local won and not synced, keep in sync queue
    - If remote won, update IndexedDB and remove from queue
    - Log conflict resolution to console

- [ ] **Task 11: Implement Sync Triggers** (AC: 7)
  - [ ] On app startup: Check navigator.onLine, call processSyncQueue() if online
  - [ ] Listen to `window` 'online' event:
    - Set syncState to 'syncing'
    - Call processSyncQueue()
    - Call pullChanges()
    - Set syncState to 'synced' or 'error'
  - [ ] Listen to `window` 'offline' event:
    - Set syncState to 'pending'
  - [ ] Expose manual sync method for pull-to-refresh

- [ ] **Task 12: Expose Sync State via Signal** (AC: 8)
  - [ ] Create `syncState = signal<SyncState>('synced')` in SyncService
  - [ ] Update syncState during sync lifecycle:
    - 'pending': Offline, operations queued
    - 'syncing': Actively syncing with Supabase
    - 'synced': All operations synced successfully
    - 'error': Sync failed after retries
  - [ ] Expose readonly signal: `getSyncState()` returns Signal<SyncState>
  - [ ] Components can subscribe to sync state changes

- [ ] **Task 13: Update Services to Use Offline Queue** (AC: 6)
  - [ ] Update GameService to queue operations:
    - createGame() -> queueOperation('games', 'insert', game)
    - updateGame() -> queueOperation('games', 'update', game)
    - deleteGame() -> queueOperation('games', 'delete', { id })
  - [ ] Update TrainingService similarly
  - [ ] All mutations go through SyncService.queueOperation()
  - [ ] Queries read from IndexedDB first, fallback to Supabase

- [ ] **Task 14: Create Unit Tests for SyncService** (AC: 9)
  - [ ] Create `/src/app/core/services/sync.service.spec.ts`
  - [ ] Mock DatabaseService (Dexie)
  - [ ] Mock SupabaseService
  - [ ] Test queueOperation() adds to sync_queue
  - [ ] Test processSyncQueue() syncs operations to Supabase
  - [ ] Test pullChanges() fetches updates from Supabase
  - [ ] Test resolveConflict() uses last-write-wins strategy
  - [ ] Test sync state transitions (pending -> syncing -> synced)
  - [ ] Test retry logic with exponential backoff
  - [ ] Verify 80% test coverage

- [ ] **Task 15: Create E2E Test for Offline Sync** (AC: 10)
  - [ ] Add test to `/tests/offline-sync.spec.ts`
  - [ ] Test: User creates game while offline
  - [ ] Test: Game stored in IndexedDB, not Supabase
  - [ ] Test: Sync status shows "pending"
  - [ ] Test: Simulate network reconnection (Playwright network API)
  - [ ] Test: Sync automatically triggers
  - [ ] Test: Game synced to Supabase
  - [ ] Test: Sync status shows "synced"
  - [ ] Verify operation removed from sync queue

## Dev Notes

### Previous Story Context
**Dependencies:** This story requires Stories 1.1-1.6 to be completed:
- Story 1.1: Angular project with PWA support
- Story 1.2: Supabase database schema
- Story 1.4: Authentication (needed for sync with auth.uid())
- Story 1.6: Dashboard with data fetching (will use offline cache)

**Architecture Foundation:**
This story implements the complete offline foundation that enables the core workflow: "Offline Game Tracking - Track game completely offline, sync when connected" [Source: architecture/8-core-workflows.md]

### PWA and Service Worker Architecture
**Technology Stack:**
- **Angular Service Worker** - PWA service worker for caching static assets [Source: architecture/3-tech-stack.md]
- **IndexedDB** - Native browser storage for offline data (no external cache technology needed) [Source: architecture/3-tech-stack.md]
- **Dexie.js** - TypeScript wrapper for IndexedDB, provides elegant API and query support [Source: architecture/3-tech-stack.md]

**Service Worker Strategy:**
- Cache app shell (HTML, CSS, JS) for instant loading [Source: architecture/15-security-and-performance.md]
- Cache static assets (fonts, icons) for offline availability
- NO API response caching (all data sync handled by IndexedDB + SyncService)
- Production builds only (dev uses live reload)

### Service Worker Configuration
**ngsw-config.json Structure:**
```json
{
  "index": "/index.html",
  "assetGroups": [
    {
      "name": "app",
      "installMode": "prefetch",
      "resources": {
        "files": [
          "/favicon.ico",
          "/index.html",
          "/manifest.webmanifest",
          "/*.css",
          "/*.js"
        ]
      }
    },
    {
      "name": "assets",
      "installMode": "lazy",
      "updateMode": "prefetch",
      "resources": {
        "files": [
          "/assets/**",
          "/*.(svg|cur|jpg|jpeg|png|apng|webp|avif|gif|otf|ttf|woff|woff2)"
        ]
      }
    }
  ],
  "dataGroups": []
}
```
[Source: architecture/3-tech-stack.md]

**Cache Strategies:**
- **prefetch**: Download immediately on install (app shell)
- **lazy**: Download on first request (images, fonts)
- **No dataGroups**: API responses not cached by Service Worker

### IndexedDB Schema with Dexie
**DatabaseService Implementation:**
```typescript
import Dexie, { Table } from 'dexie';

export class AppDatabase extends Dexie {
  teams!: Table<Team, string>;
  players!: Table<Player, string>;
  games!: Table<Game, string>;
  training_sessions!: Table<TrainingSession, string>;
  goals!: Table<Goal, string>;
  goal_assists!: Table<GoalAssist, string>;
  opponent_goals!: Table<OpponentGoal, string>;
  game_attendance!: Table<GameAttendance, string>;
  training_attendance!: Table<TrainingAttendance, string>;
  sync_queue!: Table<SyncOperation, string>;

  constructor() {
    super('TsubasaDB');

    this.version(1).stores({
      teams: '&id, created_by',
      players: '&id, team_id, coach_id',
      games: '&id, coach_id, date, status',
      training_sessions: '&id, coach_id, date, status',
      goals: '&id, game_id, scorer_id',
      goal_assists: '&id, goal_id, player_id',
      opponent_goals: '&id, game_id',
      game_attendance: '&id, game_id, player_id',
      training_attendance: '&id, training_session_id, player_id',
      sync_queue: '&id, ++timestamp, synced'
    });
  }
}

@Injectable({
  providedIn: 'root'
})
export class DatabaseService {
  public db: AppDatabase;

  constructor() {
    this.db = new AppDatabase();
  }
}
```

**Dexie Index Syntax:**
- `&id` - Primary key (unique)
- `team_id, coach_id` - Indexed columns for queries
- `++timestamp` - Auto-increment index

### Offline Sync Strategy
**Sync Architecture:**
The offline sync follows the strategy defined in the API specification:

1. **Queue Operations**: All POST/PATCH/DELETE operations queued in IndexedDB [Source: architecture/5-api-specification.md]
2. **Optimistic Responses**: Return success to UI immediately [Source: architecture/5-api-specification.md]
3. **Replay on Reconnection**: Replay queue in order when online [Source: architecture/5-api-specification.md]
4. **Conflict Resolution**: "Last write wins" based on updated_at timestamp [Source: architecture/5-api-specification.md]
5. **Retry with Backoff**: Exponential backoff for failed operations [Source: architecture/5-api-specification.md]

**Sync State Machine:**
```
pending → syncing → synced
           ↓
         error
```

### SyncService Implementation Pattern
**Service Interface:**
```typescript
@Injectable({
  providedIn: 'root'
})
export class SyncService {
  private syncState = signal<SyncState>('synced');

  constructor(
    private db: DatabaseService,
    private supabase: SupabaseService
  ) {
    this.initSyncListeners();
  }

  async queueOperation(
    table: string,
    operation: 'insert' | 'update' | 'delete',
    data: any
  ): Promise<void> {
    const syncOp: SyncOperation = {
      id: crypto.randomUUID(),
      table,
      operation,
      data,
      timestamp: Date.now(),
      synced: false,
      retries: 0
    };

    await this.db.db.sync_queue.add(syncOp);
  }

  async processSyncQueue(): Promise<SyncResult> {
    this.syncState.set('syncing');

    const queue = await this.db.db.sync_queue
      .where('synced').equals(false)
      .sortBy('timestamp');

    let successCount = 0;
    let failedCount = 0;

    for (const op of queue) {
      try {
        await this.executeOperation(op);
        await this.db.db.sync_queue.update(op.id, { synced: true });
        successCount++;
      } catch (error) {
        failedCount++;
        await this.handleSyncError(op, error);
      }
    }

    this.syncState.set(failedCount > 0 ? 'error' : 'synced');
    return { successCount, failedCount };
  }

  async pullChanges(): Promise<number> {
    const lastSync = this.getLastSyncTimestamp();

    // Query Supabase for records updated since lastSync
    // For each table, fetch changes and update IndexedDB
    // Handle conflicts with resolveConflict()

    this.setLastSyncTimestamp(Date.now());
    return changedRecordsCount;
  }

  resolveConflict(local: any, remote: any): any {
    // Last write wins based on updated_at
    return local.updated_at > remote.updated_at ? local : remote;
  }

  getSyncState(): Signal<SyncState> {
    return this.syncState.asReadonly();
  }

  private initSyncListeners() {
    // Listen to online/offline events
    fromEvent(window, 'online').subscribe(() => {
      this.processSyncQueue();
      this.pullChanges();
    });

    fromEvent(window, 'offline').subscribe(() => {
      this.syncState.set('pending');
    });

    // Sync on app startup if online
    if (navigator.onLine) {
      this.processSyncQueue();
      this.pullChanges();
    }
  }
}
```

### Conflict Resolution Strategy
**Last Write Wins Algorithm:**
```typescript
resolveConflict(local: any, remote: any): any {
  const localTimestamp = new Date(local.updated_at).getTime();
  const remoteTimestamp = new Date(remote.updated_at).getTime();

  if (localTimestamp > remoteTimestamp) {
    console.log('Conflict resolved: Local wins', { local, remote });
    return local;
  } else {
    console.log('Conflict resolved: Remote wins', { local, remote });
    return remote;
  }
}
```

**Conflict Scenarios:**
1. **Local newer**: Keep local, continue syncing
2. **Remote newer**: Update IndexedDB with remote, remove from sync queue
3. **Same timestamp**: Remote wins (server is source of truth)

### Exponential Backoff Retry Logic
**Retry Strategy:**
```typescript
async handleSyncError(op: SyncOperation, error: any): Promise<void> {
  const maxRetries = 3;

  if (op.retries < maxRetries) {
    const delay = Math.pow(2, op.retries) * 1000; // 1s, 2s, 4s

    await this.db.db.sync_queue.update(op.id, {
      retries: op.retries + 1
    });

    // Schedule retry
    setTimeout(() => this.processSyncQueue(), delay);
  } else {
    // Max retries reached, mark as failed
    await this.db.db.sync_queue.update(op.id, {
      error: error.message
    });

    this.syncState.set('error');
  }
}
```

### Integrating Offline Queue with Existing Services
**Update Pattern for Services:**
```typescript
// Before (Story 1.6):
createGame(game: Game): Observable<Game> {
  return from(
    this.supabase.client.from('games').insert(game)
  );
}

// After (Story 1.7):
async createGame(game: Game): Promise<Game> {
  // Write to IndexedDB immediately (optimistic)
  await this.db.db.games.add(game);

  // Queue for sync
  await this.syncService.queueOperation('games', 'insert', game);

  // Return immediately (no network wait)
  return game;
}

// Query pattern (read from IndexedDB first):
getUpcomingGames(limit: number): Observable<Game[]> {
  return from(
    this.db.db.games
      .where('date').aboveOrEqual(new Date())
      .where('coach_id').equals(this.authService.getUserId())
      .limit(limit)
      .toArray()
  );
}
```

**Critical Rule:**
All mutations through OfflineSyncService [Source: architecture/17-coding-standards.md]

### Sync Status Indicator
**Component Integration:**
```typescript
// In DashboardComponent
export class DashboardComponent {
  syncState = computed(() => this.syncService.getSyncState()());

  syncStatusMessage = computed(() => {
    switch (this.syncState()) {
      case 'synced': return 'All changes synced';
      case 'syncing': return 'Syncing...';
      case 'pending': return 'Offline - changes will sync when online';
      case 'error': return 'Sync error - some changes not saved';
    }
  });

  syncStatusColor = computed(() => {
    switch (this.syncState()) {
      case 'synced': return 'success';
      case 'syncing': return 'primary';
      case 'pending': return 'warning';
      case 'error': return 'error';
    }
  });
}
```

**UI Display:**
```html
<div class="sync-status" [class]="syncStatusColor()">
  <mat-icon>{{ syncState() === 'synced' ? 'cloud_done' : 'cloud_off' }}</mat-icon>
  <span>{{ syncStatusMessage() }}</span>
</div>
```

### Performance Considerations
**IndexedDB Performance:**
- Use indexes for all foreign keys [Source: architecture/15-security-and-performance.md]
- Batch operations where possible (bulk inserts)
- Query IndexedDB first, fallback to Supabase
- Limit cache size (clear old data periodically)

**Service Worker Performance:**
- Cache app shell for instant loading [Source: architecture/15-security-and-performance.md]
- Lazy load non-critical assets
- Max cache size: 50MB for images [Source: epic AC]
- Clear old caches on Service Worker update

**Sync Performance:**
- Process sync queue in batches (10 operations at a time)
- Use exponential backoff to avoid overwhelming server
- Prioritize recent operations (FIFO queue)
- Cancel duplicate operations (dedupe by id)

### Security Considerations
**Offline Data Security:**
- IndexedDB stores data in browser storage (not encrypted by default)
- Sensitive data should be minimized in cache
- JWT tokens NOT stored in IndexedDB (only in memory/sessionStorage)
- RLS policies still enforced on sync to Supabase

**Sync Security:**
- All sync operations use authenticated Supabase client (JWT in Authorization header)
- RLS policies prevent syncing to wrong user's data
- coach_id verification happens server-side
[Source: architecture/15-security-and-performance.md]

### Coding Standards
**Critical Rules:**
- **Offline Queue**: All mutations through OfflineSyncService [Source: architecture/17-coding-standards.md]
- **State Updates**: Use Signals for sync state [Source: architecture/17-coding-standards.md]
- **Type Sharing**: Define SyncOperation in core/models [Source: architecture/17-coding-standards.md]

**Naming Conventions:**
- Service: SyncService, DatabaseService
- Model: SyncOperation, SyncState
- Table names: sync_queue (snake_case in Dexie schema)
[Source: architecture/17-coding-standards.md]

### Testing Offline Functionality
**Key Test Areas:**
- Offline sync scenarios (critical for this app) [Source: architecture/16-testing-strategy.md]
- PWA functionality [Source: architecture/16-testing-strategy.md]
- Conflict resolution
- Queue processing and retry logic

## Dev Notes: Testing

### Testing Strategy for Offline Sync
**Testing Frameworks:**
- **Jasmine + Karma** - Unit tests for SyncService and conflict resolution [Source: architecture/3-tech-stack.md]
- **Playwright** - E2E tests for complete offline workflows [Source: architecture/3-tech-stack.md]

**Test Coverage:**
- SyncService: 80% statement coverage
- All sync state transitions must be tested
- Conflict resolution scenarios must be covered
[Source: architecture/16-testing-strategy.md]

### Unit Testing: SyncService
**Test File:** `/src/app/core/services/sync.service.spec.ts`

**Test Cases:**
1. `queueOperation()` - adds operation to sync queue
2. `queueOperation()` - sets synced = false and timestamp
3. `processSyncQueue()` - syncs all pending operations
4. `processSyncQueue()` - updates sync state to 'syncing'
5. `processSyncQueue()` - marks operations as synced on success
6. `processSyncQueue()` - retries failed operations with backoff
7. `processSyncQueue()` - stops after max retries
8. `pullChanges()` - fetches updates from Supabase
9. `pullChanges()` - updates last sync timestamp
10. `resolveConflict()` - local wins when newer
11. `resolveConflict()` - remote wins when newer
12. Sync triggered on app startup if online
13. Sync triggered on network reconnection
14. Sync state transitions correctly

**Mocking Strategy:**
```typescript
let mockDb: jasmine.SpyObj<DatabaseService>;
let mockSupabase: jasmine.SpyObj<SupabaseService>;

beforeEach(() => {
  mockDb = jasmine.createSpyObj('DatabaseService', {
    db: {
      sync_queue: jasmine.createSpyObj('Table', ['add', 'where', 'update', 'delete'])
    }
  });

  mockSupabase = jasmine.createSpyObj('SupabaseService', {
    client: jasmine.createSpyObj('Client', ['from'])
  });

  TestBed.configureTestingModule({
    providers: [
      SyncService,
      { provide: DatabaseService, useValue: mockDb },
      { provide: SupabaseService, useValue: mockSupabase }
    ]
  });
});
```

### E2E Testing: Offline Sync Flow
**Test File:** `/tests/offline-sync.spec.ts`

**Test Scenarios:**
1. User creates game while offline
2. Game appears in dashboard immediately (optimistic update)
3. Sync status shows "pending"
4. Network reconnects (simulate with Playwright)
5. Sync automatically triggers
6. Game syncs to Supabase
7. Sync status shows "synced"
8. Operation removed from sync queue

**Playwright Network API:**
```typescript
test('offline sync workflow', async ({ page, context }) => {
  // Login and navigate to dashboard
  await login(page);

  // Go offline
  await context.setOffline(true);

  // Create game
  await page.click('button[mat-fab]');
  await page.click('text=Create Game');
  await page.fill('input[name="opponent"]', 'Test Opponent');
  await page.click('button[type="submit"]');

  // Should show in dashboard with pending status
  await expect(page.locator('text=Test Opponent')).toBeVisible();
  await expect(page.locator('text=Offline')).toBeVisible();

  // Go online
  await context.setOffline(false);

  // Wait for sync
  await expect(page.locator('text=All changes synced')).toBeVisible();

  // Verify in Supabase (query via API)
  const game = await querySupabase('games', { opponent: 'Test Opponent' });
  expect(game).toBeTruthy();
});
```

**Testing Conflict Resolution:**
```typescript
test('conflict resolution - last write wins', async ({ page, context }) => {
  // Create game while online
  const game = await createGame(page, 'Warriors FC');

  // Go offline
  await context.setOffline(true);

  // Update game offline (updated_at = T1)
  await updateGame(page, game.id, { our_score: 3 });

  // Simulate remote update (updated_at = T2 > T1)
  await updateGameRemotely(game.id, { our_score: 5 });

  // Go online
  await context.setOffline(false);

  // Wait for sync and conflict resolution
  await page.waitForTimeout(2000);

  // Remote should win (newer updated_at)
  await expect(page.locator('text=5')).toBeVisible();
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-24 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by Dev Agent_

### Debug Log References
_To be populated by Dev Agent_

### Completion Notes List
_To be populated by Dev Agent_

### File List
_To be populated by Dev Agent_

## QA Results
_To be populated by QA Agent_
