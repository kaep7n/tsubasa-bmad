# Story 5.1: Goals Database Schema & Sync Infrastructure

## Status
Ready

## Assigned To
James (Dev Agent)

## Story
**As a** developer,
**I want** the database schema for goals, assists, and opponent goals,
**so that** game events can be tracked with proper relationships and sync state

## Acceptance Criteria
1. ✅ `goals` table with game_id, player_id, scored_at_minute, scored_at_timestamp, notes, sync_state
2. ✅ `goal_assists` junction table with goal_id, player_id, sync_state
3. ✅ `opponent_goals` table with game_id, scored_at_minute, scored_at_timestamp, sync_state
4. ✅ RLS policies: team_id isolation via joins
5. ✅ Composite indexes for performance
6. ✅ pgTAP tests: Schema constraints and RLS
7. ✅ Sync service extended for goals, assists, opponent goals
8. ✅ TypeScript types generated

## Tasks / Subtasks

- [ ] **Task 1: Create Goals Table Migration** (AC: 1)
  - [ ] Create migration file in supabase/migrations/
  - [ ] Define goals table schema:
    - id (uuid, primary key, default: gen_random_uuid())
    - game_id (uuid, foreign key to games, CASCADE, not null)
    - player_id (uuid, foreign key to players, CASCADE, not null)
    - scored_at_minute (int, not null)
    - scored_at_timestamp (timestamptz, not null)
    - notes (text, nullable)
    - created_at, updated_at, deleted_at
    - sync_state (text, default: 'synced')

- [ ] **Task 2: Create Goal Assists Junction Table** (AC: 2)
  - [ ] Define goal_assists table schema:
    - id (uuid, primary key)
    - goal_id (uuid, foreign key to goals, CASCADE, not null)
    - player_id (uuid, foreign key to players, CASCADE, not null)
    - created_at
    - sync_state (text, default: 'synced')

- [ ] **Task 3: Create Opponent Goals Table** (AC: 3)
  - [ ] Define opponent_goals table schema:
    - id (uuid, primary key)
    - game_id (uuid, foreign key to games, CASCADE, not null)
    - scored_at_minute (int, not null)
    - scored_at_timestamp (timestamptz, not null)
    - created_at, updated_at, deleted_at
    - sync_state (text, default: 'synced')

- [ ] **Task 4: Create Composite Indexes** (AC: 5)
  - [ ] Index: goals(game_id, scored_at_minute) for chronological queries
  - [ ] Index: goal_assists(goal_id) for assist lookups
  - [ ] Index: opponent_goals(game_id, scored_at_minute) for timeline

- [ ] **Task 5: Implement RLS Policies** (AC: 4)
  - [ ] Enable RLS on all three tables
  - [ ] Policy: Access via games.team_id join (transitive isolation)
  - [ ] Test: User can only access goals for their team's games

- [ ] **Task 6: Apply Migration and Generate Types** (AC: 8)
  - [ ] Run: supabase db push
  - [ ] Run: supabase gen types typescript --local

- [ ] **Task 7: Extend Sync Service** (AC: 7)
  - [ ] Update SyncService to handle goals table
  - [ ] Handle goal_assists atomically with goals
  - [ ] Handle opponent_goals with proper ordering
  - [ ] Ensure chronological sync by scored_at_timestamp

- [ ] **Task 8: Write pgTAP Tests** (AC: 6)
  - [ ] Test: Schema constraints (FK, NOT NULL)
  - [ ] Test: RLS policies isolate by team_id
  - [ ] Test: Cascading deletes work correctly

## Dev Notes

Database schema location: `supabase/migrations/`

Goals and assists are synced atomically to maintain referential integrity during offline operations.

`sync_state` field tracks synchronization status: 'pending' | 'syncing' | 'synced' | 'error'

Composite index on (game_id, scored_at_minute) enables efficient chronological timeline queries.

RLS policy transitive isolation:
```sql
CREATE POLICY "goals_select" ON goals FOR SELECT
USING (
  EXISTS (
    SELECT 1 FROM games
    WHERE games.id = goals.game_id
    AND games.team_id IN (SELECT team_id FROM team_members WHERE user_id = auth.uid())
  )
);
```

[Source: PRD Epic 5 Story 5.1, Architecture Section 4 Database Design]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-24 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by Dev Agent_

### Debug Log References
_To be populated by Dev Agent_

### Completion Notes List
_To be populated by Dev Agent_

### File List
_To be populated by Dev Agent_

## QA Results
_To be populated by QA Agent_
