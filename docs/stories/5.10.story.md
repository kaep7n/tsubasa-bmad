# Story 5.10: Offline Sync for Live Game Events

## Status
Ready

## Assigned To
James (Dev Agent)

## Story
**As a** coach,
**I want** all game events to sync automatically when connectivity returns,
**so that** I never lose tracking data due to poor stadium connectivity

## Acceptance Criteria
1. ✅ All live game operations write to IndexedDB first
2. ✅ Sync queue processes operations in chronological order
3. ✅ Goals with assists synced atomically
4. ✅ Edits applied after creates, deletes applied last
5. ✅ Conflict resolution: Last-write-wins for edits, server wins for deletes
6. ✅ Sync status indicators in scoreboard header and timeline events
7. ✅ Retry logic: Exponential backoff (1s, 2s, 4s, 8s, max 30s)
8. ✅ Background sync using Service Worker (Periodic Background Sync API)
9. ✅ Sync service emits events for analytics
10. ✅ E2E test: Log 5 goals offline, go online, verify all sync
11. ✅ E2E test: Simulate conflict, verify resolution

## Tasks / Subtasks

- [ ] **Task 1: Implement IndexedDB-First Pattern** (AC: 1)
  - [ ] All goal/assist operations write to IndexedDB immediately
  - [ ] Set sync_state = 'pending' on create/update
  - [ ] Add operation to sync queue

- [ ] **Task 2: Build Sync Queue** (AC: 2, 4)
  - [ ] Queue schema: { operation_type, entity_type, entity_id, data, timestamp }
  - [ ] Operation types: CREATE, UPDATE, DELETE
  - [ ] Process queue in order: CREATEs → UPDATEs → DELETEs
  - [ ] Chronological ordering by timestamp

- [ ] **Task 3: Implement Atomic Goal+Assists Sync** (AC: 3)
  - [ ] Group goal with its assists in sync queue
  - [ ] Sync goal first, then assists
  - [ ] If goal fails, don't sync assists (retry together)
  - [ ] All-or-nothing transaction

- [ ] **Task 4: Implement Conflict Resolution** (AC: 5)
  - [ ] Last-write-wins for edits:
    - Compare updated_at timestamps
    - If server newer, overwrite local
    - If local newer, overwrite server
  - [ ] Server wins for deletes:
    - If server deleted, accept local delete
    - Don't resurrect server-deleted records

- [ ] **Task 5: Add Sync Status Indicators** (AC: 6)
  - [ ] Scoreboard header: Cloud icon with states
    - Gray: Pending (items in queue)
    - Blue: Syncing (in progress)
    - Green: Synced (queue empty)
    - Red: Error (sync failed)
  - [ ] Timeline events: Badge on each event
    - Gray cloud: Pending
    - Green checkmark: Synced
    - Red X: Error

- [ ] **Task 6: Implement Retry Logic** (AC: 7)
  - [ ] Exponential backoff: 1s, 2s, 4s, 8s, 16s, max 30s
  - [ ] Track retry count per operation
  - [ ] Max retries: 10 attempts
  - [ ] After max retries: Mark as error, notify user

- [ ] **Task 7: Implement Background Sync** (AC: 8)
  - [ ] Service Worker: Register Periodic Background Sync
  - [ ] Sync tag: 'game-events-sync'
  - [ ] Interval: Every 5 minutes (if supported)
  - [ ] Fallback: Poll on visibility change

- [ ] **Task 8: Add Analytics Events** (AC: 9)
  - [ ] Emit events:
    - sync_success: { entity_type, entity_id, duration_ms }
    - sync_failure: { entity_type, entity_id, error, retry_count }
    - conflict_resolved: { entity_type, entity_id, resolution }
  - [ ] Log to console (dev), send to analytics service (prod)

- [ ] **Task 9: Write Tests** (AC: 10, 11)
  - [ ] E2E test: Offline scenario
    - Go offline
    - Log 5 goals
    - Verify saved to IndexedDB, sync_state='pending'
    - Go online
    - Verify all sync to Supabase
    - Verify sync_state='synced'
  - [ ] E2E test: Conflict scenario
    - Edit goal on device A
    - Edit same goal on device B (different timestamp)
    - Sync both
    - Verify last-write-wins applied

## Dev Notes

Service location: Update `/src/app/core/services/sync.service.ts`

Offline-first pattern is critical for live game tracking in stadiums with poor connectivity.

Sync queue schema:
```typescript
interface SyncOperation {
  id: string; // UUID
  operation_type: 'CREATE' | 'UPDATE' | 'DELETE';
  entity_type: 'goals' | 'goal_assists' | 'opponent_goals';
  entity_id: string;
  data: any; // Entity payload
  timestamp: string; // ISO timestamp
  retry_count: number;
  sync_state: 'pending' | 'syncing' | 'synced' | 'error';
}
```

Exponential backoff:
```typescript
const delay = Math.min(1000 * Math.pow(2, retryCount), 30000);
setTimeout(() => this.retrySync(operation), delay);
```

Atomic goal+assists sync:
```typescript
async syncGoalWithAssists(goalId: string) {
  const goal = await this.db.goals.get(goalId);
  const assists = await this.db.goal_assists.where({ goal_id: goalId }).toArray();

  try {
    await this.supabase.from('goals').upsert(goal);
    await Promise.all(assists.map(a => this.supabase.from('goal_assists').upsert(a)));
    await this.markSynced([goal.id, ...assists.map(a => a.id)]);
  } catch (error) {
    await this.markError(goal.id, error);
  }
}
```

Conflict resolution:
```typescript
if (local.updated_at > remote.updated_at) {
  // Local is newer, push to server
  await this.supabase.from('goals').update(local);
} else {
  // Server is newer, update local
  await this.db.goals.put(remote);
}
```

[Source: PRD Epic 5 Story 5.10, Architecture Section 7.2 Sync Queue Service]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-24 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by Dev Agent_

### Debug Log References
_To be populated by Dev Agent_

### Completion Notes List
_To be populated by Dev Agent_

### File List
_To be populated by Dev Agent_

## QA Results
_To be populated by QA Agent_
