# Story 6.1: Player Statistics Aggregation Service

## Status
Ready

## Assigned To
James (Dev Agent)

## Story
**As a** developer,
**I want** a service that aggregates player statistics across games,
**so that** statistics views can display accurate, performant data

## Acceptance Criteria
1. ✅ `PlayerStatsService` with methods for per-player totals and averages
2. ✅ Team totals: goals scored, conceded, W/D/L record
3. ✅ Aggregations run against IndexedDB for offline access
4. ✅ Caching strategy: Cache with last_calculated timestamp, invalidate on new data
5. ✅ Signals exposed: `playerStats()`, `teamStats()`, `isCalculating()`
6. ✅ Performance: Web Worker for aggregations, incremental for large datasets
7. ✅ TypeScript types for stats objects
8. ✅ Unit tests: Verify calculation accuracy
9. ✅ E2E test: Create 3 games with goals, verify stats aggregate

## Tasks / Subtasks

- [ ] **Task 1: Generate PlayerStatsService** (AC: 1)
  - [ ] Run: `ng generate service core/services/player-stats`
  - [ ] Methods:
    - calculatePlayerStats(dateRange?)
    - calculateTeamStats(dateRange?)
    - invalidateCache()

- [ ] **Task 2: Implement Per-Player Calculations** (AC: 1)
  - [ ] Query IndexedDB for date range:
    - games (with deleted_at IS NULL)
    - goals (joined with players)
    - goal_assists (joined with players)
    - game_attendance (status='attended')
    - training_attendance (status='attended')
  - [ ] Calculate per player:
    - gamesPlayed: COUNT DISTINCT game_attendance.game_id
    - goalsScored: COUNT goals where player_id
    - assists: COUNT goal_assists where player_id
    - attendanceRate: (attended / total games) * 100
    - trainingSessionsAttended: COUNT training_attendance

- [ ] **Task 3: Implement Team Calculations** (AC: 2)
  - [ ] Query games for date range
  - [ ] Calculate:
    - totalGamesPlayed: COUNT games
    - totalGoalsScored: COUNT goals
    - totalGoalsConceded: COUNT opponent_goals
    - wins: COUNT games where result='win'
    - draws: COUNT games where result='draw'
    - losses: COUNT games where result='loss'

- [ ] **Task 4: Implement Caching** (AC: 4)
  - [ ] Schema: stats_cache table in IndexedDB
    - cache_key (string, e.g., "player_stats_2025-season")
    - data (JSON blob)
    - last_calculated (timestamp)
  - [ ] On calculate: Check if cache exists and < 5 min old
  - [ ] If cache valid: Return cached data
  - [ ] If stale: Recalculate and update cache
  - [ ] Invalidate on: New goal, new game, attendance change

- [ ] **Task 5: Create Signals** (AC: 5)
  - [ ] Signal: playerStats (array of PlayerStats)
  - [ ] Signal: teamStats (TeamStats object)
  - [ ] Signal: isCalculating (boolean)
  - [ ] Update signals after calculation

- [ ] **Task 6: Implement Web Worker** (AC: 6)
  - [ ] Create worker: `stats-calculation.worker.ts`
  - [ ] Offload aggregation to worker
  - [ ] Post progress messages for large datasets
  - [ ] For >50 games: Process in chunks of 10

- [ ] **Task 7: Define TypeScript Types** (AC: 7)
  - [ ] Interface: PlayerStats
  - [ ] Interface: TeamStats
  - [ ] Export from models directory

- [ ] **Task 8: Write Tests** (AC: 8, 9)
  - [ ] Unit test: Mock data with 3 players, 5 games
  - [ ] Unit test: Verify goal totals
  - [ ] Unit test: Verify attendance rate calculation
  - [ ] E2E test: Create games, log goals, verify stats

## Dev Notes

Service location: `/src/app/core/services/player-stats.service.ts`

Worker location: `/src/app/core/workers/stats-calculation.worker.ts`

TypeScript types:
```typescript
interface PlayerStats {
  playerId: string;
  playerName: string;
  gamesPlayed: number;
  goalsScored: number;
  assists: number;
  attendanceRate: number; // 0-100%
  trainingSessionsAttended: number;
}

interface TeamStats {
  totalGamesPlayed: number;
  totalGoalsScored: number;
  totalGoalsConceded: number;
  wins: number;
  draws: number;
  losses: number;
  goalDifference: number;
}
```

Aggregation example:
```typescript
async calculatePlayerStats(dateRange?: DateRange): Promise<PlayerStats[]> {
  const games = await this.db.games
    .where('date').between(dateRange.start, dateRange.end)
    .and(game => game.deleted_at === null)
    .toArray();

  const players = await this.db.players.toArray();

  return players.map(player => ({
    playerId: player.id,
    playerName: `${player.first_name} ${player.last_name}`,
    gamesPlayed: await this.countGamesPlayed(player.id, games),
    goalsScored: await this.countGoals(player.id, games),
    assists: await this.countAssists(player.id, games),
    attendanceRate: await this.calculateAttendanceRate(player.id, games),
    trainingSessionsAttended: await this.countTrainingSessions(player.id)
  }));
}
```

[Source: PRD Epic 6 Story 6.1, Architecture Section 8 State Management]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-24 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by Dev Agent_

### Debug Log References
_To be populated by Dev Agent_

### Completion Notes List
_To be populated by Dev Agent_

### File List
_To be populated by Dev Agent_

## QA Results
_To be populated by QA Agent_
