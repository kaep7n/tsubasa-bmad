# Story 6.10: Statistics Performance Optimization

## Status
Ready

## Assigned To
James (Dev Agent)

## Story
**As a** developer,
**I want** statistics calculations to be performant with large datasets,
**so that** the app remains responsive even after multiple seasons

## Acceptance Criteria
1. ✅ Aggregation benchmarks: <500ms for 1 season, <2s for 3 seasons, <5s for 5 seasons
2. ✅ Optimizations: Web Worker, incremental calculation, indexed queries, memoization, virtual scrolling
3. ✅ Progress indicators: Spinner with percentage for calculations >1s
4. ✅ Lazy loading: Charts load after initial stats, on-demand calculation
5. ✅ Memory management: Release large query results, destroy chart instances
6. ✅ Performance monitoring: Console logs, Performance.mark() calls
7. ✅ Unit test: Verify benchmarks with simulated datasets
8. ✅ E2E test: Create 50-game dataset, verify stats load within targets

## Tasks / Subtasks

- [ ] **Task 1: Define Benchmark Targets** (AC: 1)
  - [ ] 1 season (20 games, 15 players, ~50 goals): <500ms
  - [ ] 3 seasons (60 games, 15 players, ~150 goals): <2s
  - [ ] 5 seasons (100 games, 20 players, ~300 goals): <5s

- [ ] **Task 2: Implement Web Worker for Aggregations** (AC: 2)
  - [ ] Move aggregation logic to stats-calculation.worker.ts
  - [ ] Main thread sends data to worker
  - [ ] Worker returns calculated stats
  - [ ] Non-blocking UI during calculation

- [ ] **Task 3: Implement Incremental Calculation** (AC: 2)
  - [ ] For large datasets (>50 games):
    - Process in chunks of 10 games
    - Yield control between chunks
    - Post progress updates to main thread

- [ ] **Task 4: Optimize IndexedDB Queries** (AC: 2)
  - [ ] Compound indexes:
    - goals(game_id, player_id)
    - game_attendance(game_id, player_id)
    - games(team_id, date)
  - [ ] Use efficient query patterns (avoid full table scans)

- [ ] **Task 5: Implement Memoization** (AC: 2)
  - [ ] Cache frequently accessed calculations
  - [ ] Use Map for in-memory cache
  - [ ] TTL: 5 minutes
  - [ ] Invalidate on data changes

- [ ] **Task 6: Implement Virtual Scrolling** (AC: 2)
  - [ ] Player Stats table: Use CDK Virtual Scroll for >50 players
  - [ ] Only render visible rows
  - [ ] Improves rendering performance

- [ ] **Task 7: Add Progress Indicators** (AC: 3)
  - [ ] Show spinner for calculations >1s
  - [ ] Display percentage: "Calculating statistics... 45%"
  - [ ] Update every chunk completion

- [ ] **Task 8: Implement Lazy Loading** (AC: 4)
  - [ ] Charts load after initial stats render
  - [ ] Chart data calculated on-demand when tab viewed
  - [ ] Defer non-critical calculations

- [ ] **Task 9: Implement Memory Management** (AC: 5)
  - [ ] Release large query results after aggregation
  - [ ] Destroy Chart.js instances on component unmount
  - [ ] Clear caches periodically

- [ ] **Task 10: Add Performance Monitoring** (AC: 6)
  - [ ] Console logs for calculation times (dev mode)
  - [ ] Performance.mark() and Performance.measure()
  - [ ] Log: "Stats calculation took 342ms"

- [ ] **Task 11: Write Tests** (AC: 7, 8)
  - [ ] Unit test: Simulate 1 season, verify <500ms
  - [ ] Unit test: Simulate 3 seasons, verify <2s
  - [ ] E2E test: Create 50-game dataset with mock data
  - [ ] E2E test: Load player stats, verify renders within target

## Dev Notes

Worker location: `/src/app/core/workers/stats-calculation.worker.ts`

Benchmark test data generation:
```typescript
function generateMockSeason(games: number, players: number, goalsPerGame: number) {
  // Generate mock games, goals, assists
  // Return dataset
}
```

Incremental calculation pattern:
```typescript
async function calculateStatsIncremental(games: Game[]): Promise<PlayerStats[]> {
  const chunkSize = 10;
  const totalChunks = Math.ceil(games.length / chunkSize);

  let allStats: PlayerStats[] = [];

  for (let i = 0; i < totalChunks; i++) {
    const chunk = games.slice(i * chunkSize, (i + 1) * chunkSize);
    const chunkStats = await calculateChunk(chunk);
    allStats = mergeStats(allStats, chunkStats);

    // Post progress
    postMessage({ type: 'progress', percent: ((i + 1) / totalChunks) * 100 });

    // Yield control
    await sleep(0);
  }

  return allStats;
}
```

Compound index creation:
```typescript
this.db.version(1).stores({
  goals: 'id, [game_id+player_id], game_id, player_id',
  game_attendance: 'id, [game_id+player_id], game_id, player_id'
});
```

Performance monitoring:
```typescript
performance.mark('stats-calc-start');
await this.calculateStats();
performance.mark('stats-calc-end');
performance.measure('stats-calculation', 'stats-calc-start', 'stats-calc-end');
const duration = performance.getEntriesByName('stats-calculation')[0].duration;
console.log(`Stats calculation took ${duration}ms`);
```

Virtual scrolling:
```html
<cdk-virtual-scroll-viewport itemSize="48" class="player-table">
  <tr *cdkVirtualFor="let player of players">
    <td>{{ player.name }}</td>
    <td>{{ player.goalsScored }}</td>
  </tr>
</cdk-virtual-scroll-viewport>
```

[Source: PRD Epic 6 Story 6.10, Architecture Section 15 Performance Considerations]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-24 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by Dev Agent_

### Debug Log References
_To be populated by Dev Agent_

### Completion Notes List
_To be populated by Dev Agent_

### File List
_To be populated by Dev Agent_

## QA Results
_To be populated by QA Agent_
